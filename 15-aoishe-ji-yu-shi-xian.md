# 1.5 AOI设计与实现

前边，我们已经完成了四个类中的三个了，接下来就是要实现GameRole类了。于此的同时，游戏相关的核心消息处理逻辑都是要在该类中实现的。

**需求回首：** 

+ 新客户端连接后，向其发送ID和名称
+ 新客户端连接后，向其发送**周围**玩家的位置
+ 新客户端连接后，向**周围**玩家发送其位置
+ 收到客户端的移动信息后，向**周围**玩家发送其新位置
+ 收到客户端的移动信息后，向其发送**周围新**玩家位置
+ 收到客户端的聊天信息后，向**所有**玩家发送聊天内容
+ 客户端断开时，向**周围**玩家发送其断开的消息

关键字：周围。

以上所列出的需求，基本都是这样的套路：发送XXX消息给XXX。

+ 发送：`bool Server::send_resp(Response * pstResp)`
+ XXX消息：1.4节已经搞定
+ 给XXX：怎样表示周围玩家？

## 1.5.1 AOI算法简介

**定义：** 获取感兴趣的区域（Area Of Interest）的算法。

**解决的问题：** 形成周围的概念。在多人游戏中，各个游戏客户端之间需要通过服务器向彼此更新自身状态。但对于当玩家来说，我们不需要获取“太远”的玩家的信息，所以，在服务器端，我们通过AOI算法可以获取到某个客户端“周围”的玩家，进而只在该小范围内同步信息。

**网格法AOI**：

+ 参考游戏世界的坐标，创建一个边界相同的矩形。
+ 选取适当的颗粒度，将矩形分割成几×几的网格。
+ 每个客户端都要按照实际坐标添加到某个格子里。
+ 客户端所在格子的周围八个格子内的玩家就是周围玩家。

**举例：** 世界坐标是X[20,200]，Y[50,230]，划分成6×6的网格为：

![](/assets/游戏网格.png)

1. 已知玩家坐标（x，y），该玩家在几号网格？
> 网格编号=(x-x轴起始坐标)/x轴网格宽度 + (y-y轴起始坐标)/y轴宽度*x轴网格数量
> x轴网格宽度=(x轴结束坐标-x轴起始坐标)/x轴网格数量；y轴的计算方式相同
2. 已知玩家在n号网格，周围的格子(包括自己)有哪些？

![](/assets/周围网格.png)

## 1.5.2 AOI算法实现

+ 网格类用于存放网格内的玩家：封装一个list用于添加和删除玩家
+ 世界地图类用于构造和表示所有网格
  + 属性：x和y轴的起始结束坐标，x和y轴的网格数
  + 网格表示：封装一个vector存放所有的网格对象，网格序号按照vector存储序号表示
  + 主要函数：根据坐标获取网格，根据网格号获取周围网格




